# EtherFlow 项目关键代码整理

## 目录
- [钱包交互](#钱包交互)
  - [钱包连接](#钱包连接)
  - [头像信息获取](#头像信息获取)
  - [网络切换逻辑](#网络切换逻辑)
  - [获取网络逻辑](#获取网络逻辑)
  - [发起钱包转账逻辑](#发起钱包转账逻辑)
  - [获取钱包余额逻辑](#获取钱包余额逻辑)
  - [获取交易信息逻辑](#获取交易信息逻辑)
- [合约交互](#合约交互)
  - [获取合约变量逻辑](#获取合约变量逻辑)
  - [获取合约日志逻辑](#获取合约日志逻辑)

---

## 钱包交互

### 钱包连接

#### 1. Wagmi 方式连接钱包
**文件**: `src/app/components/WalletConnect.tsx`

```typescript
// 导入 wagmi 库中的钱包连接相关 hooks
import { useAccount, useConnect, useDisconnect, useBalance, useSendTransaction, useSwitchChain } from 'wagmi'
import { parseEther } from 'viem'

export default function WalletConnect() {
  // useAccount hook - 获取当前钱包账户信息
  const { 
    address,        // 当前连接的钱包地址 (string | undefined)
    isConnected,    // 钱包是否已连接 (boolean)
    chain          // 当前连接的网络链信息 (Chain | undefined)
  } = useAccount()

  // useConnect hook - 提供钱包连接功能
  const { 
    connect,        // 连接钱包的函数，接受连接器参数
    connectors,     // 可用的钱包连接器列表 (Connector[])
    isPending       // 连接过程是否正在进行中 (boolean)
  } = useConnect()

  // useDisconnect hook - 提供钱包断开连接功能
  const { 
    disconnect      // 断开钱包连接的函数
  } = useDisconnect()

  // useSwitchChain hook - 提供网络切换功能
  const { 
    switchChain     // 切换网络链的函数，接受链ID参数
  } = useSwitchChain()

  // useBalance hook - 获取钱包余额信息
  const { 
    data: balance,           // 余额数据对象，包含 value、formatted 等属性
    isLoading: balanceLoading, // 余额加载状态 (boolean)
    error: balanceError,     // 余额查询错误信息
    refetch: refetchBalance  // 重新获取余额的函数
  } = useBalance({
    address: address,        // 要查询余额的地址
  })

  // 转账表单状态管理
  const [toAddress, setToAddress] = useState('')  // 接收方地址
  const [amount, setAmount] = useState('')        // 转账金额

  // useSendTransaction hook - 提供发送交易功能
  const { 
    sendTransaction,              // 发送交易的函数
    isPending: isTransferPending, // 交易发送过程中的加载状态
    isSuccess,                   // 交易是否发送成功
    error                        // 交易发送过程中的错误信息
  } = useSendTransaction({
    mutation: {
      onSuccess: () => {
        // 转账成功后刷新余额
        setTimeout(() => {
          refetchBalance()
        }, 2000) // 等待2秒让交易确认
      }
    }
  })

  // 处理转账的函数
  const handleTransfer = () => {
    // 检查输入是否完整
    if (!toAddress || !amount) return
    
    // 将ETH金额转换为Wei单位
    const amountInWei = parseEther(amount)
    
    // 检查余额是否足够
    if (balance && amountInWei > balance.value) {
      alert('余额不足！')
      return
    }
    
    try {
      // 发送交易
      sendTransaction({
        to: toAddress as `0x${string}`,  // 接收方地址，类型断言为0x开头的字符串
        value: amountInWei,              // 转账金额（Wei单位）
      })
    } catch (err) {
      console.error('Transfer failed:', err)
    }
  }

  // 检查余额是否不足的函数
  const isInsufficientBalance = () => {
    if (!balance || !amount) return false
    try {
      const amountInWei = parseEther(amount)
      return amountInWei > balance.value
    } catch {
      return false
    }
  }

  // 切换到本地网络（链ID: 1337）
  const switchToLocalhost = () => {
    switchChain({ chainId: 1337 })
  }

  // 格式化余额显示的函数
  const formatBalance = (balance: any) => {
    if (!balance) return '0'
    const balanceInEth = Number(balance.value) / 1e18  // 将Wei转换为ETH
    return balanceInEth.toFixed(4) // 保留4位小数
  }
}
```

#### Wagmi Hooks 详细说明

**useAccount Hook**
- **作用**: 获取当前钱包账户的状态信息
- **返回值**:
  - `address`: 当前连接的钱包地址，格式为 `0x...`，未连接时为 `undefined`
  - `isConnected`: 布尔值，表示钱包是否已成功连接
  - `chain`: 当前连接的网络链对象，包含链ID、名称、RPC URL等信息

**useConnect Hook**
- **作用**: 提供钱包连接功能和相关状态
- **返回值**:
  - `connect`: 连接钱包的函数，需要传入连接器参数
  - `connectors`: 可用的钱包连接器数组，包括 MetaMask、WalletConnect 等
  - `isPending`: 连接过程中的加载状态，用于显示连接中的UI

**useDisconnect Hook**
- **作用**: 提供钱包断开连接功能
- **返回值**:
  - `disconnect`: 断开钱包连接的函数，调用后会清除连接状态

**useSwitchChain Hook**
- **作用**: 提供网络切换功能
- **返回值**:
  - `switchChain`: 切换网络链的函数，接受链ID参数

**useBalance Hook**
- **作用**: 获取钱包余额信息
- **返回值**:
  - `data`: 余额数据对象，包含 value、formatted 等属性
  - `isLoading`: 余额加载状态
  - `error`: 余额查询错误信息
  - `refetch`: 重新获取余额的函数

**useSendTransaction Hook**
- **作用**: 提供发送交易功能
- **返回值**:
  - `sendTransaction`: 发送交易的函数
  - `isPending`: 交易发送过程中的加载状态
  - `isSuccess`: 交易是否发送成功
  - `error`: 交易发送过程中的错误信息

#### 2. 原生 MetaMask 连接
**文件**: `metamask-connect.html`

```javascript
// 检查是否安装了 MetaMask
function checkMetaMask() {
  if (typeof window.ethereum !== 'undefined') {
    return true
  } else {
    alert('请安装 MetaMask 插件')
    return false
  }
}

// 连接钱包
async function connectWallet() {
  if (!checkMetaMask()) return

  try {
    const accounts = await window.ethereum.request({
      method: 'eth_requestAccounts'
    })
    
    if (accounts.length > 0) {
      currentAccount = accounts[0]
      updateUI()
      await getBalance()
    }
  } catch (error) {
    console.error('连接失败:', error)
  }
}
```

#### 3. Ethers.js 方式连接
**文件**: `src/app/components/ContractInterface.tsx`

```typescript
import { ethers } from 'ethers'

const connectWallet = async () => {
  try {
    if (typeof window.ethereum !== 'undefined') {
      const provider = new ethers.BrowserProvider(window.ethereum)
      const signer = await provider.getSigner()
      
      setProvider(provider)
      setSigner(signer)
      setIsConnected(true)
      
      await fetchContractState()
    } else {
      console.error('MetaMask未安装')
    }
  } catch (error) {
    console.error('连接钱包失败:', error)
  }
}
```

### 头像信息获取

#### 1. ENS 头像获取
**文件**: `src/app/components/WalletInfo.tsx`

```typescript
import { useEnsName, useEnsAvatar } from 'wagmi'

export default function WalletInfo() {
  const { address } = useAccount()
  const { data: ensName } = useEnsName({ address })
  const { data: ensAvatar } = useEnsAvatar({ name: ensName || undefined })

  // 生成默认头像
  const generateAvatarUrl = (address: string) => {
    return `https://api.dicebear.com/7.x/identicon/svg?seed=${address}&backgroundColor=f3f4f6&size=32`
  }

  // 显示头像
  <img
    src={ensAvatar || generateAvatarUrl(address)}
    alt="Account Avatar"
    className="w-8 h-8 rounded-full"
    onError={(e) => {
      (e.target as HTMLImageElement).src = generateAvatarUrl(address)
    }}
  />
}
```

#### 2. ENS 测试功能
**文件**: `src/app/components/EnsTest.tsx`

```typescript
const testEnsLookup = async () => {
  if (!testAddress || !ethers.isAddress(testAddress)) return

  setLoading(true)
  try {
    if (typeof window.ethereum !== 'undefined') {
      const provider = new ethers.BrowserProvider(window.ethereum)
      
      // 查询ENS名称
      const name = await provider.lookupAddress(testAddress)
      
      // 查询ENS头像
      let avatar = null
      if (name) {
        try {
          const resolver = await provider.getResolver(testAddress)
          if (resolver) {
            const avatarResult = await resolver.getAvatar()
            if (avatarResult && typeof avatarResult === 'string') {
              avatar = avatarResult
            } else if (avatarResult && typeof avatarResult === 'object' && (avatarResult as any).url) {
              avatar = (avatarResult as any).url
            }
          }
        } catch (error) {
          console.log('获取头像失败:', error)
        }
      }

      setEnsResult({ name, avatar })
    }
  } catch (error) {
    console.error('ENS查询失败:', error)
  } finally {
    setLoading(false)
  }
}
```

### 网络切换逻辑

#### 1. Wagmi 网络切换
**文件**: `src/app/components/UniswapNetworkSelector.tsx`

```typescript
import { useSwitchChain, useChainId } from 'wagmi'
import { mainnet, polygon, arbitrum, optimism, sepolia } from 'wagmi/chains'

export default function UniswapNetworkSelector() {
  const { switchChain } = useSwitchChain()
  const chainId = useChainId()

  const supportedChains = [
    { id: 1337, name: 'Localhost', icon: '🏠' },
    { id: sepolia.id, name: 'Sepolia', icon: '🧪' },
    { id: mainnet.id, name: 'Ethereum', icon: '🔷' },
    { id: polygon.id, name: 'Polygon', icon: '🟣' },
    { id: arbitrum.id, name: 'Arbitrum', icon: '🔵' },
    { id: optimism.id, name: 'Optimism', icon: '🔴' },
  ]

  const handleChainSwitch = (chainId: number) => {
    switchChain({ chainId })
    setShowDropdown(false)
  }
}
```

#### 2. 简单网络切换
**文件**: `src/app/components/WalletConnect.tsx`

```typescript
const switchToLocalhost = () => {
  switchChain({ chainId: 1337 })
}
```

### 获取网络逻辑

#### 1. 获取当前网络信息
**文件**: `src/app/components/WalletInfo.tsx`

```typescript
import { useChainId } from 'wagmi'

export default function WalletInfo() {
  const chainId = useChainId()
  
  const supportedChains = [
    { ...mainnet, icon: '🔷' },
    { ...polygon, icon: '🟣' },
    { ...arbitrum, icon: '🔵' },
    { ...optimism, icon: '🔴' },
  ]

  const currentChain = supportedChains.find(chain => chain.id === chainId) || supportedChains[0]
}
```

#### 2. 监听网络变化
**文件**: `metamask-connect.html`

```javascript
// 监听网络变化
if (typeof window.ethereum !== 'undefined') {
  window.ethereum.on('chainChanged', function (chainId) {
    console.log('网络已切换到:', chainId)
    if (currentAccount) {
      getBalance()
    }
  })
}
```

### 发起钱包转账逻辑

#### 1. Wagmi 转账
**文件**: `src/app/components/WalletConnect.tsx`

```typescript
import { useSendTransaction } from 'wagmi'
import { parseEther } from 'viem'

export default function WalletConnect() {
  const { sendTransaction, isPending: isTransferPending, isSuccess, error } = useSendTransaction({
    mutation: {
      onSuccess: () => {
        // 转账成功后刷新余额
        setTimeout(() => {
          refetchBalance()
        }, 2000)
      }
    }
  })

  const handleTransfer = () => {
    if (!toAddress || !amount) return
    
    const amountInWei = parseEther(amount)
    if (balance && amountInWei > balance.value) {
      alert('余额不足！')
      return
    }
    
    try {
      sendTransaction({
        to: toAddress as `0x${string}`,
        value: amountInWei,
      })
    } catch (err) {
      console.error('Transfer failed:', err)
    }
  }
}
```

#### 2. Ethers.js 转账
**文件**: `src/app/components/ContractInterface.tsx`

```typescript
const handleTransfer = async () => {
  if (!signer || !ethers.isAddress(transferData.to) || !transferData.amount) {
    return
  }

  setLoading(true)
  try {
    const amountWei = ethers.parseEther(transferData.amount)
    const tx = await signer.sendTransaction({
      to: transferData.to,
      value: amountWei
    })
    
    await tx.wait()
    setTransferData({ to: '', amount: '' })
    setOperationStatus({ type: 'success', message: '转账成功' })
  } catch (error) {
    console.error('转账失败:', error)
    setOperationStatus({ type: 'error', message: '转账失败' })
  } finally {
    setLoading(false)
  }
}
```

### 获取钱包余额逻辑

#### 1. Wagmi 余额查询
**文件**: `src/app/components/WalletConnect.tsx`

```typescript
import { useBalance } from 'wagmi'

export default function WalletConnect() {
  const { data: balance, isLoading: balanceLoading, error: balanceError, refetch: refetchBalance } = useBalance({
    address: address,
  })

  const formatBalance = (balance: any) => {
    if (!balance) return '0'
    const balanceInEth = Number(balance.value) / 1e18
    return balanceInEth.toFixed(4)
  }
}
```

#### 2. 原生 MetaMask 余额查询
**文件**: `metamask-connect.html`

```javascript
// 获取余额
async function getBalance() {
  if (!currentAccount) return

  try {
    const balance = await window.ethereum.request({
      method: 'eth_getBalance',
      params: [currentAccount, 'latest']
    })
    
    const balanceInEth = parseInt(balance, 16) / Math.pow(10, 18)
    document.getElementById('accountBalance').textContent = balanceInEth.toFixed(4)
  } catch (error) {
    console.error('获取余额失败:', error)
  }
}
```

### 获取交易信息逻辑

#### 1. 交易查询功能
**文件**: `src/app/components/ContractInterface.tsx`

```typescript
interface ITransactionData {
  hash: string
  from: string
  to: string
  value: string
  gasPrice: string
  gasLimit: string
  nonce: number
  data: string
  blockNumber: number
  blockHash: string
  timestamp: number
  confirmations: number | (() => Promise<number>)
  status: number
}

const handleQueryTransaction = async () => {
  if (!provider || !transactionHash.trim()) {
    setTransactionError('请输入有效的交易哈希')
    return
  }

  setTransactionLoading(true)
  setTransactionError('')
  setTransactionData(null)

  try {
    // 验证交易哈希格式
    if (!/^0x([A-Fa-f0-9]{64})$/.test(transactionHash)) {
      throw new Error('无效的交易哈希格式')
    }

    // 获取交易收据
    const receipt = await provider.getTransactionReceipt(transactionHash)
    if (!receipt) {
      throw new Error('交易不存在或尚未被打包')
    }

    // 获取交易详情
    const tx = await provider.getTransaction(transactionHash)
    if (!tx) {
      throw new Error('无法获取交易详情')
    }

    // 获取区块信息
    const block = await provider.getBlock(receipt.blockNumber!)
    
    // 格式化交易数据
    const formattedData: ITransactionData = {
      hash: tx.hash,
      from: tx.from,
      to: tx.to || '',
      value: ethers.formatEther(tx.value),
      gasPrice: ethers.formatUnits(tx.gasPrice || 0, 'gwei'),
      gasLimit: tx.gasLimit?.toString() || '0',
      nonce: tx.nonce,
      data: tx.data,
      blockNumber: receipt.blockNumber!,
      blockHash: receipt.blockHash,
      timestamp: block?.timestamp || 0,
      confirmations: typeof receipt.confirmations === 'function' ? await receipt.confirmations() : receipt.confirmations,
      status: receipt.status || 0
    }

    setTransactionData(formattedData)
  } catch (error) {
    console.error('查询交易失败:', error)
    setTransactionError(error instanceof Error ? error.message : '查询失败')
  } finally {
    setTransactionLoading(false)
  }
}
```

#### 2. 独立交易查询脚本
**文件**: `demo-transaction-query.js`

```javascript
async function queryTransaction(txHash, rpcUrl = 'https://eth.llamarpc.com') {
  try {
    console.log('🔍 开始查询交易:', txHash)
    
    // 创建provider
    const provider = new ethers.JsonRpcProvider(rpcUrl)
    
    // 验证交易哈希格式
    if (!/^0x([A-Fa-f0-9]{64})$/.test(txHash)) {
      throw new Error('无效的交易哈希格式')
    }
    
    // 获取交易收据
    const receipt = await provider.getTransactionReceipt(txHash)
    if (!receipt) {
      throw new Error('交易不存在或尚未被打包')
    }
    
    // 获取交易详情
    const tx = await provider.getTransaction(txHash)
    if (!tx) {
      throw new Error('无法获取交易详情')
    }
    
    // 获取区块信息
    const block = await provider.getBlock(receipt.blockNumber)
    
    // 格式化交易数据
    const transactionData = {
      hash: tx.hash,
      from: tx.from,
      to: tx.to || '合约调用',
      value: ethers.formatEther(tx.value),
      gasPrice: ethers.formatUnits(tx.gasPrice || 0, 'gwei'),
      gasLimit: tx.gasLimit?.toString() || '0',
      nonce: tx.nonce,
      data: tx.data,
      blockNumber: receipt.blockNumber,
      blockHash: receipt.blockHash,
      timestamp: block?.timestamp || 0,
      confirmations: receipt.confirmations,
      status: receipt.status === 1 ? '成功' : '失败'
    }
    
    console.log('🎉 交易查询成功!')
    console.log(JSON.stringify(transactionData, null, 2))
    
    return transactionData
  } catch (error) {
    console.error('❌ 交易查询失败:', error.message)
    throw error
  }
}
```

---

## 合约交互

contract 对象包含了智能合约的所有公开接口

### 获取合约变量逻辑

#### 1. 合约状态获取
**文件**: `src/app/components/ContractInterface.tsx`

```typescript
// 获取合约状态
const fetchContractState = async () => {
  if (!contract) return
  
  try {
    const [messageResult, countResult, ownerResult] = await Promise.all([
      contract.getMessage(),
      contract.getCount(),
      contract.getOwner()
    ])
    
    setMessage(messageResult)
    setCount(Number(countResult))
    setOwner(ownerResult)
    
    // 同时刷新合约事件
    contractEventsRef.current?.refresh()
  } catch (error) {
    console.error('获取合约状态失败:', error)
    // 设置默认值，避免显示空白
    setMessage('合约未连接或地址错误')
    setCount(0)
    setOwner('未知')
  }
}
```

#### 2. Wagmi 合约读取
**文件**: `src/app/components/RedPacketGrabbing.tsx`

```typescript
import { useReadContract } from 'wagmi'

const contractAbi = [
  {
    name: 'totalAmount',
    type: 'function',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'count',
    type: 'function',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'uint256' }],
  },
  {
    name: 'isEqual',
    type: 'function',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ type: 'bool' }],
  },
  {
    name: 'isGrabbed',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ type: 'address' }],
    outputs: [{ type: 'uint256' }],
  },
] as const

const { data: totalAmount } = useReadContract({
  address: contractAddress as `0x${string}`,
  abi: contractAbi,
  functionName: 'totalAmount',
})

const { data: count } = useReadContract({
  address: contractAddress as `0x${string}`,
  abi: contractAbi,
  functionName: 'count',
})

const { data: isEqual } = useReadContract({
  address: contractAddress as `0x${string}`,
  abi: contractAbi,
  functionName: 'isEqual',
})
```

#### 3. 合约配置
**文件**: `src/app/config/contract.ts`

```typescript
export const CONTRACT_CONFIG = {
  // 合约地址
  address: process.env.NEXT_PUBLIC_CONTRACT_ADDRESS || '0x23C1684494DaBE62458154757301bD86B46DaCa5',
  
  // 合约ABI
  abi: [
    {
      "inputs": [],
      "name": "getCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getMessage",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ]
}
```

### 获取合约日志逻辑

#### 1. 合约事件查询组件
**文件**: `src/app/components/ContractEvents.tsx`

```typescript
interface IEventData {
  countIncremented: ICountIncrementedEvent[]
  messageUpdated: IMessageUpdatedEvent[]
}

const ContractEvents = forwardRef<IContractEventsRef, IContractEventsProps>(({ 
  contractAddress = ''
}, ref) => {
  const [events, setEvents] = useState<IEventData>({
    countIncremented: [],
    messageUpdated: []
  })
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')

  const GRAPH_ENDPOINT = 'https://api.studio.thegraph.com/query/119874/tx/v0.0.2'

  // 查询合约事件
  const fetchContractEvents = async (address: string) => {
    if (!address.trim()) {
      setError('请输入合约地址')
      return
    }

    setLoading(true)
    setError('')

    try {
      const query = `
        {
          countIncrementeds(first: 5) {
            id
            newCount
            blockNumber
            blockTimestamp
          }
          messageUpdateds(first: 5) {
            id
            newMessage
            updatedBy
            blockNumber
          }
        }
      `

      const response = await fetch(GRAPH_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ query })
      })
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()

      if (data.errors) {
        throw new Error(data.errors[0]?.message || 'GraphQL查询错误')
      }

      setEvents({
        countIncremented: data.data?.countIncrementeds || [],
        messageUpdated: data.data?.messageUpdateds || []
      })

      setLastQueryTime(new Date())
    } catch (err) {
      console.error('查询合约事件失败:', err)
      setError(err instanceof Error ? err.message : '查询失败')
    } finally {
      setLoading(false)
    }
  }

  // 刷新事件
  const handleRefresh = () => {
    if (contractAddress.trim()) {
      fetchContractEvents(contractAddress)
    }
  }

  // 暴露刷新方法给父组件
  useImperativeHandle(ref, () => ({
    refresh: handleRefresh
  }))
}
```

#### 2. 事件数据结构
**文件**: `src/app/components/ContractEvents.tsx`

```typescript
interface ICountIncrementedEvent {
  id: string
  newCount: string
  blockNumber: string
  blockTimestamp: string
  transactionHash: string
}

interface IMessageUpdatedEvent {
  id: string
  newMessage: string
  updatedBy: string
  blockNumber: string
  blockTimestamp: string
  transactionHash: string
}
```

#### 3. 合约事件 ABI 定义
**文件**: `src/app/config/contract.ts`

```typescript
{
  "anonymous": false,
  "inputs": [
    {
      "indexed": false,
      "internalType": "uint256",
      "name": "newCount",
      "type": "uint256"
    }
  ],
  "name": "CountIncremented",
  "type": "event"
},
{
  "anonymous": false,
  "inputs": [
    {
      "indexed": false,
      "internalType": "string",
      "name": "newMessage",
      "type": "string"
    },
    {
      "indexed": false,
      "internalType": "address",
      "name": "updatedBy",
      "type": "address"
    }
  ],
  "name": "MessageUpdated",
  "type": "event"
}
```

#### 4. 事件格式化工具函数
**文件**: `src/app/components/ContractEvents.tsx`

```typescript
// 格式化时间戳
const formatTimestamp = (timestamp: string) => {
  const date = new Date(Number(timestamp) * 1000)
  return date.toLocaleString('zh-CN', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  })
}

// 截断地址显示
const truncateAddress = (address: string) => {
  return `${address.slice(0, 6)}...${address.slice(-4)}`
}

// 截断交易哈希显示
const truncateHash = (hash: string) => {
  return `${hash.slice(0, 10)}...${hash.slice(-8)}`
}
```

---

## 总结

这个 EtherFlow 项目展示了完整的 Web3 应用开发模式，包含了：

### 钱包交互功能
- **多种连接方式**: Wagmi、原生 MetaMask、Ethers.js
- **ENS 支持**: 名称解析和头像获取
- **网络管理**: 多链支持和网络切换
- **转账功能**: 完整的转账流程和余额管理
- **交易查询**: 详细的交易信息获取

### 合约交互功能
- **状态读取**: 多种方式读取合约变量
- **事件监听**: 通过 The Graph 查询合约事件
- **合约调用**: 支持读取和写入操作

### 技术特点
- **TypeScript**: 完整的类型安全
- **现代化 UI**: Uniswap 风格的设计
- **错误处理**: 完善的错误处理机制
- **响应式设计**: 支持移动端和桌面端
- **性能优化**: 使用 lodash 进行防抖处理

这个项目为 Web3 应用开发提供了完整的参考实现。
